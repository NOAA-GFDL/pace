import math
import os

import numpy as np
import pytest
import xarray as xr
import yaml

import ndsl.util
from ndsl.util.comm.mpi import MPIComm
from ndsl.util.constants import PI, RADIUS
from pace.driver import Driver, DriverConfig


DIR = os.path.dirname(os.path.abspath(__file__))
TEST_CONFIGS_DIR = os.path.join(DIR, "../../../driver/examples/configs/")
TEST_DATA_DIR = os.path.join(DIR, "../../../test_input/")

TEST_CONFIG_FILE_RANKS = [
    ("test_external_C12_1x1.yaml", 6),
    ("test_external_C12_2x2.yaml", 24),
]

TILE_FILE_BASE_NAME = "C12.tile"


def get_cube_comm(layout, comm: MPIComm):
    return ndsl.util.CubedSphereCommunicator(
        comm=comm,
        partitioner=ndsl.util.CubedSpherePartitioner(
            ndsl.util.TilePartitioner(layout=layout)
        ),
    )


def get_tile_num(comm: MPIComm):
    return ndsl.util.get_tile_number(comm.rank, comm.partitioner.total_ranks)


# TODO: Location of test configurations and data will be changed
#       after refactor, need to update after


@pytest.mark.parametrize("config_file_path, ranks", TEST_CONFIG_FILE_RANKS)
def test_extgrid_equals_generated(config_file_path: str, ranks: int):
    """
    Test for matching values between what exists in external grid
    file, and what is generated by Pace when using an "external"
    grid configuration. The "external" grid configuration takes
    d-grid values as input and Pace then calculates the remaining
    metric terms from this data.

    External grid files are expected to be of Netcdf type
    (for reference see method of generating grid data in
    FRE-NCtools) and contain values for the longitudinal,
    latitude, distance between longitude and latitude points,
    and cell areas.

    On a run, the user should specify the correct number of ranks,
    location of configuration yaml, and base name for the tile files
    containing the grid data.

    ON PASS: Input and generated data will match, with zero, or
    insignificant relative difference. Each rank will print a
    list of maximum relative differences for each metric term
    tested.

    ON FAIL: There will be a mismatch present between input and
    generated grid data values. Mismatch can be determined from the
    printed list of errors and the list of maximum relative differences
    """

    comm = MPIComm()
    size = comm.Get_size()
    if size != ranks:
        pytest.skip("Number of ranks does not match amount needed for layout")
    side = int(math.sqrt(size // 6))
    cube_comm = get_cube_comm(layout=(side, side), comm=comm)

    with open(
        os.path.join(TEST_CONFIGS_DIR, config_file_path),
        "r",
    ) as ext_f:
        ext_config = yaml.safe_load(ext_f)
        ext_driver_config = DriverConfig.from_dict(ext_config)

    ext_driver = Driver(ext_driver_config)

    tile_num = get_tile_num(cube_comm)
    tile_file = TILE_FILE_BASE_NAME + str(tile_num) + ".nc"
    ds = xr.open_dataset(os.path.join(TEST_DATA_DIR, tile_file))
    lon = ds.x.values
    lat = ds.y.values
    dx = ds.dx.values
    dy = ds.dy.values
    area = ds.area.values
    nx = ds.nx.values.size
    ny = ds.ny.values.size
    npx = ds.nxp.values.size
    npy = ds.nyp.values.size

    subtile_slice_grid = cube_comm.partitioner.tile.subtile_slice(
        rank=cube_comm.rank,
        global_dims=[ndsl.util.Y_INTERFACE_DIM, ndsl.util.X_INTERFACE_DIM],
        global_extent=(npy, npx),
        overlap=True,
    )

    subtile_slice_dx = cube_comm.partitioner.tile.subtile_slice(
        rank=cube_comm.rank,
        global_dims=[ndsl.util.Y_INTERFACE_DIM, ndsl.util.X_DIM],
        global_extent=(npy, nx),
        overlap=True,
    )

    subtile_slice_dy = cube_comm.partitioner.tile.subtile_slice(
        rank=cube_comm.rank,
        global_dims=[ndsl.util.Y_DIM, ndsl.util.X_INTERFACE_DIM],
        global_extent=(ny, npx),
        overlap=True,
    )

    subtile_slice_area = cube_comm.partitioner.tile.subtile_slice(
        rank=cube_comm.rank,
        global_dims=[ndsl.util.Y_DIM, ndsl.util.X_DIM],
        global_extent=(ny, nx),
        overlap=True,
    )

    lon_rad = lon * (PI / 180)
    lat_rad = lat * (PI / 180)

    errors = []
    diffs = []

    if not np.isclose(
        ext_driver.state.grid_data.lon.view[:, :], lon_rad[subtile_slice_grid]
    ).all():
        errors.append("Lon data mismatch")

    diff_lon = np.amax(
        ext_driver.state.grid_data.lon.view[:, :] - lon_rad[subtile_slice_grid]
    ) / np.amax(lon_rad[subtile_slice_grid])
    diffs.append(f"Lon maximum relative error = {diff_lon}")

    if not np.isclose(
        ext_driver.state.grid_data.lat.view[:, :], lat_rad[subtile_slice_grid]
    ).all():
        errors.append("Lat data mismatch")

    diff_lat = np.amax(
        ext_driver.state.grid_data.lat.view[:, :] - lat_rad[subtile_slice_grid]
    ) / np.amax(lat_rad[subtile_slice_grid])
    diffs.append(f"Lat maximum relative error = {diff_lat}")

    if not np.isclose(
        ext_driver.state.grid_data.dy.view[:, :], dx[subtile_slice_dx]
    ).all():
        errors.append("dx data mismatch")

    diff_dx = np.amax(
        ext_driver.state.grid_data.dy.view[:, :] - dx[subtile_slice_dx]
    ) / np.amax(dx[subtile_slice_dx])
    diffs.append(f"dx maximum relative error = {diff_dx}")

    if not np.isclose(
        ext_driver.state.grid_data.dx.view[:, :], dy[subtile_slice_dy]
    ).all():
        errors.append("dy data mismatch")

    diff_dy = np.amax(
        ext_driver.state.grid_data.dx.view[:, :] - dy[subtile_slice_dy]
    ) / np.amax(dy[subtile_slice_dy])
    diffs.append(f"dy maximum relative error = {diff_dy}")

    if not np.isclose(
        ext_driver.state.grid_data.area.view[:, :], area[subtile_slice_area]
    ).all():
        errors.append("area data mismatch")

    diff_area = np.amax(
        ext_driver.state.grid_data.area.view[:, :] - area[subtile_slice_area]
    ) / np.amax(area[subtile_slice_area])
    diffs.append(f"Area maximum relative error = {diff_area}")

    print(diffs)

    assert not errors, "errors occured in 2x2:\n{}".format("\n".join(errors))

    surface_area_true = 4 * PI * (RADIUS ** 2)

    mpicomm = MPIComm()

    tmp = [math.fsum(row) for row in ext_driver.state.grid_data.area.view[:, :]]
    rank_area_sum = math.fsum(tmp)
    tile_area = mpicomm._comm.gather(rank_area_sum, root=0)

    if mpicomm.Get_rank() == 0:
        total_area = math.fsum(tile_area)
        assert np.isclose(total_area, surface_area_true)
